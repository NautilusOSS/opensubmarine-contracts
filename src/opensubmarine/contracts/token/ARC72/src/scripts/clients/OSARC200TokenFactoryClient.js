/* eslint-disable */
// @ts-nocheck
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^2
 */
import * as algokit from '@algorandfoundation/algokit-utils';
import { AtomicTransactionComposer, modelsv2 } from 'algosdk';
export const APP_SPEC = {
    "hints": {
        "create()uint64": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "set_version(uint64,uint64)void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "approve_update(bool)void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "grant_upgrader(address)void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "transfer(address)void": {
            "call_config": {
                "no_op": "CALL"
            }
        }
    },
    "source": {
        "approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCgpjb250cmFjdC5PU0FSQzIwMFRva2VuRmFjdG9yeS5hcHByb3ZhbF9wcm9ncmFtOgogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGJueiBtYWluX2VudHJ5cG9pbnRAMgogICAgY2FsbHN1YiBfX2luaXRfXwoKbWFpbl9lbnRyeXBvaW50QDI6CiAgICAvLyBzcmMvc3JjL2NvbnRyYWN0LnB5OjEyMDgKICAgIC8vIGNsYXNzIE9TQVJDMjAwVG9rZW5GYWN0b3J5KEJhc2VGYWN0b3J5KToKICAgIHR4biBOdW1BcHBBcmdzCiAgICBieiBtYWluX2JhcmVfcm91dGluZ0AxMQogICAgbWV0aG9kICJjcmVhdGUoKXVpbnQ2NCIKICAgIG1ldGhvZCAic2V0X3ZlcnNpb24odWludDY0LHVpbnQ2NCl2b2lkIgogICAgbWV0aG9kICJhcHByb3ZlX3VwZGF0ZShib29sKXZvaWQiCiAgICBtZXRob2QgImdyYW50X3VwZ3JhZGVyKGFkZHJlc3Mpdm9pZCIKICAgIG1ldGhvZCAidHJhbnNmZXIoYWRkcmVzcyl2b2lkIgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAogICAgbWF0Y2ggbWFpbl9jcmVhdGVfcm91dGVANCBtYWluX3NldF92ZXJzaW9uX3JvdXRlQDUgbWFpbl9hcHByb3ZlX3VwZGF0ZV9yb3V0ZUA2IG1haW5fZ3JhbnRfdXBncmFkZXJfcm91dGVANyBtYWluX3RyYW5zZmVyX3JvdXRlQDgKICAgIGVyciAvLyByZWplY3QgdHJhbnNhY3Rpb24KCm1haW5fY3JlYXRlX3JvdXRlQDQ6CiAgICAvLyBzcmMvc3JjL2NvbnRyYWN0LnB5OjEyMTIKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiBjcmVhdGUKICAgIGl0b2IKICAgIGJ5dGUgMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludCAxCiAgICByZXR1cm4KCm1haW5fc2V0X3ZlcnNpb25fcm91dGVANToKICAgIC8vIHNyYy9zcmMvY29udHJhY3QucHk6NDY0CiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBpcyBub3QgY3JlYXRpbmcKICAgIC8vIHNyYy9zcmMvY29udHJhY3QucHk6MTIwOAogICAgLy8gY2xhc3MgT1NBUkMyMDBUb2tlbkZhY3RvcnkoQmFzZUZhY3RvcnkpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgLy8gc3JjL3NyYy9jb250cmFjdC5weTo0NjQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgY2FsbHN1YiBzZXRfdmVyc2lvbgogICAgaW50IDEKICAgIHJldHVybgoKbWFpbl9hcHByb3ZlX3VwZGF0ZV9yb3V0ZUA2OgogICAgLy8gc3JjL3NyYy9jb250cmFjdC5weTo0ODIKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgLy8gc3JjL3NyYy9jb250cmFjdC5weToxMjA4CiAgICAvLyBjbGFzcyBPU0FSQzIwMFRva2VuRmFjdG9yeShCYXNlRmFjdG9yeSk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICAvLyBzcmMvc3JjL2NvbnRyYWN0LnB5OjQ4MgogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBjYWxsc3ViIGFwcHJvdmVfdXBkYXRlCiAgICBpbnQgMQogICAgcmV0dXJuCgptYWluX2dyYW50X3VwZ3JhZGVyX3JvdXRlQDc6CiAgICAvLyBzcmMvc3JjL2NvbnRyYWN0LnB5OjQ4OAogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gaXMgbm90IGNyZWF0aW5nCiAgICAvLyBzcmMvc3JjL2NvbnRyYWN0LnB5OjEyMDgKICAgIC8vIGNsYXNzIE9TQVJDMjAwVG9rZW5GYWN0b3J5KEJhc2VGYWN0b3J5KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIC8vIHNyYy9zcmMvY29udHJhY3QucHk6NDg4CiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIGNhbGxzdWIgZ3JhbnRfdXBncmFkZXIKICAgIGludCAxCiAgICByZXR1cm4KCm1haW5fdHJhbnNmZXJfcm91dGVAODoKICAgIC8vIHNyYy9zcmMvY29udHJhY3QucHk6NzkKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgaW50IDEKICAgIHJldHVybgoKbWFpbl9iYXJlX3JvdXRpbmdAMTE6CiAgICAvLyBzcmMvc3JjL2NvbnRyYWN0LnB5OjEyMDgKICAgIC8vIGNsYXNzIE9TQVJDMjAwVG9rZW5GYWN0b3J5KEJhc2VGYWN0b3J5KToKICAgIGludCAwCiAgICBpbnQgNAogICAgdHhuIE9uQ29tcGxldGlvbgogICAgbWF0Y2ggbWFpbl9jcmVhdGVAMTIgbWFpbl9vbl91cGRhdGVAMTMKICAgIGVyciAvLyByZWplY3QgdHJhbnNhY3Rpb24KCm1haW5fY3JlYXRlQDEyOgogICAgLy8gc3JjL3NyYy9jb250cmFjdC5weToxMjA4CiAgICAvLyBjbGFzcyBPU0FSQzIwMFRva2VuRmFjdG9yeShCYXNlRmFjdG9yeSk6CiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgIQogICAgYXNzZXJ0IC8vIGlzIGNyZWF0aW5nCiAgICBpbnQgMQogICAgcmV0dXJuCgptYWluX29uX3VwZGF0ZUAxMzoKICAgIC8vIHNyYy9zcmMvY29udHJhY3QucHk6NDczCiAgICAvLyBAYXJjNC5iYXJlbWV0aG9kKGFsbG93X2FjdGlvbnM9WyJVcGRhdGVBcHBsaWNhdGlvbiJdKQogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBpcyBub3QgY3JlYXRpbmcKICAgIC8vIHNyYy9zcmMvY29udHJhY3QucHk6NDczLTQ3NAogICAgLy8gQGFyYzQuYmFyZW1ldGhvZChhbGxvd19hY3Rpb25zPVsiVXBkYXRlQXBwbGljYXRpb24iXSkKICAgIC8vIGRlZiBvbl91cGRhdGUoc2VsZikgLT4gTm9uZToKICAgIGNhbGxzdWIgb25fdXBkYXRlCiAgICBpbnQgMQogICAgcmV0dXJuCgoKLy8gY29udHJhY3QuT1NBUkMyMDBUb2tlbkZhY3RvcnkuY3JlYXRlKCkgLT4gdWludDY0OgpjcmVhdGU6CiAgICAvLyBzcmMvc3JjL2NvbnRyYWN0LnB5OjEyMTItMTIxOQogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICAvLyBkZWYgY3JlYXRlKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgIyBuYW1lOiBCeXRlczMyLAogICAgLy8gICAgICMgc3ltYm9sOiBCeXRlczgsCiAgICAvLyAgICAgIyBkZWNpbWFsczogYXJjNC5VSW50OCwKICAgIC8vICAgICAjIHRvdGFsU3VwcGx5OiBhcmM0LlVJbnQyNTYsCiAgICAvLyApIC0+IFVJbnQ2NDoKICAgIHByb3RvIDAgMQogICAgLy8gc3JjL3NyYy9jb250cmFjdC5weToxMjMyLTEyMzMKICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwogICAgLy8gc2VsZi5nZXRfaW5pdGlhbF9wYXltZW50KCkKICAgIGNhbGxzdWIgZ2V0X2luaXRpYWxfcGF5bWVudAogICAgcG9wCiAgICAvLyBzcmMvc3JjL2NvbnRyYWN0LnB5OjEyMzgKICAgIC8vIGJhc2VfYXBwID0gYXJjNC5hcmM0X2NyZWF0ZShPU0FSQzIwMFRva2VuLCBjb21waWxlZD1jb21waWxlZCkuY3JlYXRlZF9hcHAKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNyYy9zcmMvY29udHJhY3QucHk6MTIzNC0xMjM3CiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMKICAgIC8vIGNvbXBpbGVkID0gY29tcGlsZV9jb250cmFjdCgKICAgIC8vICAgICBPU0FSQzIwMFRva2VuLCBleHRyYV9wcm9ncmFtX3BhZ2VzPTMKICAgIC8vICkgICMgbWF4IGV4dHJhIHBhZ2VzCiAgICBpbnQgNgogICAgaXR4bl9maWVsZCBHbG9iYWxOdW1VaW50CiAgICBpbnQgNwogICAgaXR4bl9maWVsZCBHbG9iYWxOdW1CeXRlU2xpY2UKICAgIC8vIHNyYy9zcmMvY29udHJhY3QucHk6MTIzNgogICAgLy8gT1NBUkMyMDBUb2tlbiwgZXh0cmFfcHJvZ3JhbV9wYWdlcz0zCiAgICBpbnQgMwogICAgaXR4bl9maWVsZCBFeHRyYVByb2dyYW1QYWdlcwogICAgLy8gc3JjL3NyYy9jb250cmFjdC5weToxMjM0LTEyMzcKICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwogICAgLy8gY29tcGlsZWQgPSBjb21waWxlX2NvbnRyYWN0KAogICAgLy8gICAgIE9TQVJDMjAwVG9rZW4sIGV4dHJhX3Byb2dyYW1fcGFnZXM9MwogICAgLy8gKSAgIyBtYXggZXh0cmEgcGFnZXMKICAgIGJ5dGUgYmFzZTY0IENvRUJRdz09CiAgICBpdHhuX2ZpZWxkIENsZWFyU3RhdGVQcm9ncmFtUGFnZXMKICAgIGJ5dGUgYmFzZTY0IENpQUdBQUVnQmNDRVBRSW1FZ1FWSDN4MUFBVnZkMjVsY2doMWNHZHlZV1JsY2dSdVlXMWxCbk41YldKdmJBdDBiM1JoYkZOMWNIQnNlUWhpWVd4aGJtTmxjd2hrWld4bFoyRjBaUWhrWldOcGJXRnNjd0dBQ1hWd1pHRjBZV0pzWlFSNWc4TmNJQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUNXRndjSEp2ZG1Gc2N4QmpiMjUwY21GamRGOTJaWEp6YVc5dUVtUmxjR3h2ZVcxbGJuUmZkbVZ5YzJsdmJnbHdZWEpsYm5SZmFXUXhHRUFBQTRnRldURWJRUUc0Z2hFRXlLT242QVM1d2hGVkJHVjlFK3dFdHE0YUpRU0U3QlBWQk95WllFRUVndVZ6eEFTN3N4bnpCRXFXajQ4RTJuQWx1UVMxUWlFbEJIaThtZFFFYXd1UCtBVFVscjlEQkY5K29rZ0V6U1RlaUFTdCtTcmtOaG9BamhFQUFRQVpBQ1lBTmdCR0FGWUFaZ0I1QUk4QXFBQytBTlFBNWdEMUFRUUJFd0V4QURFWkZFUXhHRVEyR2dFMkdnSTJHZ00yR2dTSUFVQWpRekVaSlJKRU1SaEVpQUhDSTBNeEdSUkVNUmhFaUFKRUtFeFFzQ05ETVJrVVJERVlSSWdDUFNoTVVMQWpRekVaRkVReEdFU0lBallvVEZDd0kwTXhHUlJFTVJoRWlBSXpLRXhRc0NORE1Sa1VSREVZUkRZYUFZZ0NNU2hNVUxBalF6RVpGRVF4R0VRMkdnRTJHZ0tJQWpvb1RGQ3dJME14R1JSRU1SaEVOaG9CTmhvQ05ob0RpQUpIS0V4UXNDTkRNUmtVUkRFWVJEWWFBVFlhQW9nQzJDaE1VTEFqUXpFWkZFUXhHRVEyR2dFMkdnS0lBdEVvVEZDd0kwTXhHUlJFTVJoRU5ob0JOaG9DaUFMS0kwTXhHUlJFTVJoRU5ob0JpQUxqSTBNeEdSUkVNUmhFTmhvQmlBTDRJME14R1JSRU1SaEVOaG9CaUFNSEkwTXhHUlJFTVJoRU5ob0JOaG9DTmhvRE5ob0VOaG9GTmhvR2lBTWJJME14R1JSRU1SaEVJME1pZ1FReEdZNENBQUVBQ2dBeEdCUkVpQU5wSTBNeEdFU0lBMjBqUTRvRUFDSXFaVVF5QXhKRUlpY0VaVVFwRWtRaUp3VmxSQ2tTUkNJbkJtVkVLYWhFTVFDSUFFY2hCQTlFS2pJSlp5Y0VpL3huSndXTC9XZUwvaGNuQ1V4bkp3YUwvMmNuQnpFQVVFbThTSXYvdnpJRE1RQlFpLzlRSnd4TVVMQ3hNZ2toQkxJSXNnY2pzaEFpc2dHemlZb0JBVEVXU1VRakNVazRFQ01TUkVrNEFJdi9Fa1JKT0FjeUNoSkVPQWlKaWdBQU1RQWlLMlZFRWtReEFJZ0FBWW1LQVFBeEdTVVNSRElKTWdHeGdFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFzajhpc2c0aXNnMGlzZ3duRGJJTEp3MnlDaU95T1NFRnNoQWlzZ0cyc2dpTC83SUpzZ2Nqc2hBaXNnR3ppWW9BQVNJbkJHVkVpWW9BQVNJbkJXVkVpWW9BQVNJbkNXVkVGbGNIQVltS0FBRWlKd1psUkVrVkpBNUVKSytyaVlvQkFZdi9pQUFKU1JVa0RrUWtyNnVKaWdFQkp3ZUwvMUMrS1U0Q1RZbUtBZ0dML292L2lBQUpTUlVrRGtRa3I2dUppZ0lCaS82TC8xQUJKdzVNVUw0cFRnSk5pWW9EQVl2OWkvNkwvNGdBQXljS2lZb0RBREVBaS8xTEFZai8wa21MLzZkRWkvK2hpLzFPQW9nQUNvdjlpLzZMLzRnQUs0bUtBd0NML1l2K1VFa0JKdzVNVUVtOFNJdi92NHYvRlNRT1JDU3ZpLytyVUlBRUdXbjRaVXhRc0ltS0F3Q0wvWWovWm92K2lQOWhURW1MLzZkRUp3ZUwvVkJNaS8raFRFbThTRXkvSndlTC9sQk1pLytnVEVtOFNFeS9pLzhWSkE1RUpLK0wvNnVML1l2K1VFeFFKd3hNVUxDSmlnSUJNUUNML292L2lQK3JKd3FKaWdJQk1RQ0wvb3YvaVA5eUp3cUppZ0lBTVFBaUsyVkVFa1NML292L1VJQUVqSXo1elV4UXNJditGeWNQVEdlTC94Y25FRXhuaVlvQkFERUFJaXBsUkJKRUlpcGxSSXYvVUlBRXdubGxpMHhRc0l2L0lsTW5DMHhuaVlvQkFERUFNZ2tTUkNJclpVU0wvMUNBQkszMTRyaE1VTEFyaS85bmlZb0JBREVBSWlwbFJCSkFBQWd4QURJSkVrRUFCQ05DQUFFaVJDSW5DR1ZFaS85UWdBUjRabFYzVEZDd0p3aUwvMmVKaWdZQU1RQWlLbVZFRWtBQUN6RUFJaWNJWlVRU1FRQUVJMElBQVNKRU1nQXhBSWo5VjBzQkVrUXhBRW1MK2xDTCsxQ0wvRkNML1ZDTC9sQ0wvMUJRZ0FSdFJKQS9URkN3c1l2OEY0djlGNHYrRjR2L3NqK3lEcklOc2d5TCs3SUxpL3F5Q2lFRnNoQ3lBYk9KaWdBQU1nMUpSQ2NSVEdlSmlnQUFNUUFpSzJWRUVrUWlKd3RsUkNNU1JJbUtBQUFuQkNsbkp3VXBaeWNKSW1jbkJpbG5KeEVpWjRBSVpHVndiRzk1WlhJeUEyY3FNZ05uSnc4aVp5Y1FJbWNuQ3lObkt6SUpaeWNJTWdObmdBbHpkR0ZyWldGaWJHVWpaNGs9CiAgICBpdHhuX2ZpZWxkIEFwcHJvdmFsUHJvZ3JhbVBhZ2VzCiAgICAvLyBzcmMvc3JjL2NvbnRyYWN0LnB5OjEyMzgKICAgIC8vIGJhc2VfYXBwID0gYXJjNC5hcmM0X2NyZWF0ZShPU0FSQzIwMFRva2VuLCBjb21waWxlZD1jb21waWxlZCkuY3JlYXRlZF9hcHAKICAgIGludCBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnQgMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIENyZWF0ZWRBcHBsaWNhdGlvbklECiAgICAvLyBzcmMvc3JjL2NvbnRyYWN0LnB5OjEyMzkKICAgIC8vIGFyYzQuZW1pdChGYWN0b3J5Q3JlYXRlZChhcmM0LlVJbnQ2NChiYXNlX2FwcC5pZCkpKQogICAgZHVwCiAgICBpdG9iCiAgICBtZXRob2QgIkZhY3RvcnlDcmVhdGVkKHVpbnQ2NCkiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgLy8gc3JjL3NyYy9jb250cmFjdC5weToxMjQwLTEyNDQKICAgIC8vIGFyYzQuYWJpX2NhbGwoICAjIGluaGVyaXQgdXBncmFkZXIKICAgIC8vICAgICBPU0FSQzIwMFRva2VuLmdyYW50X3VwZ3JhZGVyLAogICAgLy8gICAgIEdsb2JhbC5jcmVhdG9yX2FkZHJlc3MsCiAgICAvLyAgICAgYXBwX2lkPWJhc2VfYXBwLAogICAgLy8gKQogICAgaXR4bl9iZWdpbgogICAgLy8gc3JjL3NyYy9jb250cmFjdC5weToxMjQyCiAgICAvLyBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzLAogICAgZ2xvYmFsIENyZWF0b3JBZGRyZXNzCiAgICBkaWcgMQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICAvLyBzcmMvc3JjL2NvbnRyYWN0LnB5OjEyNDAtMTI0NAogICAgLy8gYXJjNC5hYmlfY2FsbCggICMgaW5oZXJpdCB1cGdyYWRlcgogICAgLy8gICAgIE9TQVJDMjAwVG9rZW4uZ3JhbnRfdXBncmFkZXIsCiAgICAvLyAgICAgR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywKICAgIC8vICAgICBhcHBfaWQ9YmFzZV9hcHAsCiAgICAvLyApCiAgICBtZXRob2QgImdyYW50X3VwZ3JhZGVyKGFkZHJlc3Mpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaW50IGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludCAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNyYy9zcmMvY29udHJhY3QucHk6MTI0NS0xMjQ3CiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgcmVjZWl2ZXI9YmFzZV9hcHAuYWRkcmVzcywgYW1vdW50PW9wLkdsb2JhbC5taW5fYmFsYW5jZSArIDMxMzAwLCBmZWU9MAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgLy8gc3JjL3NyYy9jb250cmFjdC5weToxMjQ2CiAgICAvLyByZWNlaXZlcj1iYXNlX2FwcC5hZGRyZXNzLCBhbW91bnQ9b3AuR2xvYmFsLm1pbl9iYWxhbmNlICsgMzEzMDAsIGZlZT0wCiAgICBkdXAKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIGdsb2JhbCBNaW5CYWxhbmNlCiAgICBpbnQgMzEzMDAKICAgICsKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICAvLyBzcmMvc3JjL2NvbnRyYWN0LnB5OjEyNDUKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIGludCBwYXkKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIC8vIHNyYy9zcmMvY29udHJhY3QucHk6MTI0NgogICAgLy8gcmVjZWl2ZXI9YmFzZV9hcHAuYWRkcmVzcywgYW1vdW50PW9wLkdsb2JhbC5taW5fYmFsYW5jZSArIDMxMzAwLCBmZWU9MAogICAgaW50IDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzcmMvc3JjL2NvbnRyYWN0LnB5OjEyNDUtMTI0NwogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPWJhc2VfYXBwLmFkZHJlc3MsIGFtb3VudD1vcC5HbG9iYWwubWluX2JhbGFuY2UgKyAzMTMwMCwgZmVlPTAKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzcmMvc3JjL2NvbnRyYWN0LnB5OjEyNDgtMTI0OQogICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCiAgICAvLyByZXR1cm4gYmFzZV9hcHAuaWQKICAgIHJldHN1YgoKCi8vIGNvbnRyYWN0LkJhc2VGYWN0b3J5LmdldF9pbml0aWFsX3BheW1lbnQoKSAtPiB1aW50NjQ6CmdldF9pbml0aWFsX3BheW1lbnQ6CiAgICAvLyBzcmMvc3JjL2NvbnRyYWN0LnB5OjExOTAtMTE5MQogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiBnZXRfaW5pdGlhbF9wYXltZW50KHNlbGYpIC0+IFVJbnQ2NDoKICAgIHByb3RvIDAgMQogICAgLy8gc3JjL3NyYy9jb250cmFjdC5weToxMTk1CiAgICAvLyBwYXltZW50X2Ftb3VudCA9IHJlcXVpcmVfcGF5bWVudChUeG4uc2VuZGVyKQogICAgdHhuIFNlbmRlcgogICAgY2FsbHN1YiByZXF1aXJlX3BheW1lbnQKICAgIC8vIHNyYy9zcmMvY29udHJhY3QucHk6MTE5NwogICAgLy8gbWluX2JhbGFuY2UgPSBvcC5HbG9iYWwubWluX2JhbGFuY2UgICMgMTAwMDAwCiAgICBnbG9iYWwgTWluQmFsYW5jZQogICAgLy8gc3JjL3NyYy9jb250cmFjdC5weToxMTk2CiAgICAvLyBtYnJfaW5jcmVhc2UgPSBVSW50NjQobWludF9jb3N0KQogICAgaW50IDMxMzAwCiAgICAvLyBzcmMvc3JjL2NvbnRyYWN0LnB5OjExOTkKICAgIC8vIHBheW1lbnRfYW1vdW50ID49IG1icl9pbmNyZWFzZSArIG1pbl9iYWxhbmNlCiAgICBkaWcgMQogICAgKwogICAgZGlnIDIKICAgIDw9CiAgICAvLyBzcmMvc3JjL2NvbnRyYWN0LnB5OjExOTgtMTIwMAogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBwYXltZW50X2Ftb3VudCA+PSBtYnJfaW5jcmVhc2UgKyBtaW5fYmFsYW5jZQogICAgLy8gKSwgInBheW1lbnQgYW1vdW50IGFjY3VyYXRlIiAgIyAxMzEzMDAKICAgIGFzc2VydCAvLyBwYXltZW50IGFtb3VudCBhY2N1cmF0ZQogICAgLy8gc3JjL3NyYy9jb250cmFjdC5weToxMjAxCiAgICAvLyBpbml0aWFsID0gcGF5bWVudF9hbW91bnQgLSBtYnJfaW5jcmVhc2UgLSBtaW5fYmFsYW5jZQogICAgc3dhcAogICAgLy8gc3JjL3NyYy9jb250cmFjdC5weToxMTk2CiAgICAvLyBtYnJfaW5jcmVhc2UgPSBVSW50NjQobWludF9jb3N0KQogICAgaW50IDMxMzAwCiAgICAvLyBzcmMvc3JjL2NvbnRyYWN0LnB5OjEyMDEKICAgIC8vIGluaXRpYWwgPSBwYXltZW50X2Ftb3VudCAtIG1icl9pbmNyZWFzZSAtIG1pbl9iYWxhbmNlCiAgICAtCiAgICBzd2FwCiAgICAtCiAgICAvLyBzcmMvc3JjL2NvbnRyYWN0LnB5OjEyMDIKICAgIC8vIHJldHVybiBpbml0aWFsCiAgICByZXRzdWIKCgovLyB1dGlscy5yZXF1aXJlX3BheW1lbnQod2hvOiBieXRlcykgLT4gdWludDY0OgpyZXF1aXJlX3BheW1lbnQ6CiAgICAvLyBzcmMvc3JjL3V0aWxzLnB5OjE1LTIzCiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCiAgICAvLyAjIGZ1bmN0aW9uOiByZXF1aXJlX3BheW1lbnQgKGludGVybmFsKQogICAgLy8gIyBhcmd1bWVudHM6IE5vbmUKICAgIC8vICMgcHVycG9zZTogY2hlY2sgcGF5bWVudAogICAgLy8gIyBwcmUtY29uZGl0aW9uczogTm9uZQogICAgLy8gIyBwb3N0LWNvbmRpdGlvbnM6IE5vbmUKICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMKICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgcmVxdWlyZV9wYXltZW50KHdobzogQWNjb3VudCkgLT4gVUludDY0OgogICAgcHJvdG8gMSAxCiAgICAvLyBzcmMvc3JjL3V0aWxzLnB5OjI0CiAgICAvLyByZWZfZ3JvdXBfaW5kZXggPSBUeG4uZ3JvdXBfaW5kZXgKICAgIHR4biBHcm91cEluZGV4CiAgICAvLyBzcmMvc3JjL3V0aWxzLnB5OjI1CiAgICAvLyBhc3NlcnQgcmVmX2dyb3VwX2luZGV4ID4gMCwgImdyb3VwIGluZGV4IGdyZWF0ZXIgdGhhbiB6ZXJvIgogICAgZHVwCiAgICBhc3NlcnQgLy8gZ3JvdXAgaW5kZXggZ3JlYXRlciB0aGFuIHplcm8KICAgIC8vIHNyYy9zcmMvdXRpbHMucHk6MjYKICAgIC8vIHBheW1lbnRfZ3JvdXBfaW5kZXggPSByZWZfZ3JvdXBfaW5kZXggLSAxCiAgICBpbnQgMQogICAgLQogICAgLy8gc3JjL3NyYy91dGlscy5weToyOAogICAgLy8gZ3R4bi5QYXltZW50VHJhbnNhY3Rpb24ocGF5bWVudF9ncm91cF9pbmRleCkuc2VuZGVyID09IHdobwogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50IHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgZHVwCiAgICBndHhucyBTZW5kZXIKICAgIGZyYW1lX2RpZyAtMQogICAgPT0KICAgIC8vIHNyYy9zcmMvdXRpbHMucHk6MjctMjkKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgZ3R4bi5QYXltZW50VHJhbnNhY3Rpb24ocGF5bWVudF9ncm91cF9pbmRleCkuc2VuZGVyID09IHdobwogICAgLy8gKSwgInBheW1lbnQgc2VuZGVyIGFjY3VyYXRlIgogICAgYXNzZXJ0IC8vIHBheW1lbnQgc2VuZGVyIGFjY3VyYXRlCiAgICAvLyBzcmMvc3JjL3V0aWxzLnB5OjMxCiAgICAvLyBndHhuLlBheW1lbnRUcmFuc2FjdGlvbihwYXltZW50X2dyb3VwX2luZGV4KS5yZWNlaXZlcgogICAgZHVwCiAgICBndHhucyBSZWNlaXZlcgogICAgLy8gc3JjL3NyYy91dGlscy5weTozMgogICAgLy8gPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcwogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIC8vIHNyYy9zcmMvdXRpbHMucHk6MzEtMzIKICAgIC8vIGd0eG4uUGF5bWVudFRyYW5zYWN0aW9uKHBheW1lbnRfZ3JvdXBfaW5kZXgpLnJlY2VpdmVyCiAgICAvLyA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICA9PQogICAgLy8gc3JjL3NyYy91dGlscy5weTozMC0zMwogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBndHhuLlBheW1lbnRUcmFuc2FjdGlvbihwYXltZW50X2dyb3VwX2luZGV4KS5yZWNlaXZlcgogICAgLy8gICAgID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIC8vICksICJwYXltZW50IHJlY2VpdmVyIGFjY3VyYXRlIgogICAgYXNzZXJ0IC8vIHBheW1lbnQgcmVjZWl2ZXIgYWNjdXJhdGUKICAgIC8vIHNyYy9zcmMvdXRpbHMucHk6MzQKICAgIC8vIHJldHVybiBndHhuLlBheW1lbnRUcmFuc2FjdGlvbihwYXltZW50X2dyb3VwX2luZGV4KS5hbW91bnQKICAgIGd0eG5zIEFtb3VudAogICAgcmV0c3ViCgoKLy8gY29udHJhY3QuVXBncmFkZWFibGUuc2V0X3ZlcnNpb24oY29udHJhY3RfdmVyc2lvbjogYnl0ZXMsIGRlcGxveW1lbnRfdmVyc2lvbjogYnl0ZXMpIC0+IHZvaWQ6CnNldF92ZXJzaW9uOgogICAgLy8gc3JjL3NyYy9jb250cmFjdC5weTo0NjQtNDY3CiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIC8vIGRlZiBzZXRfdmVyc2lvbigKICAgIC8vICAgICBzZWxmLCBjb250cmFjdF92ZXJzaW9uOiBhcmM0LlVJbnQ2NCwgZGVwbG95bWVudF92ZXJzaW9uOiBhcmM0LlVJbnQ2NAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMiAwCiAgICAvLyBzcmMvc3JjL2NvbnRyYWN0LnB5OjQ2OAogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gc2VsZi51cGdyYWRlciwgIm11c3QgYmUgdXBncmFkZXIiCiAgICB0eG4gU2VuZGVyCiAgICBpbnQgMAogICAgLy8gc3JjL3NyYy9jb250cmFjdC5weTo0MTUKICAgIC8vIHNlbGYudXBncmFkZXIgPSBBY2NvdW50KCkKICAgIGJ5dGUgInVwZ3JhZGVyIgogICAgLy8gc3JjL3NyYy9jb250cmFjdC5weTo0NjgKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyID09IHNlbGYudXBncmFkZXIsICJtdXN0IGJlIHVwZ3JhZGVyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnVwZ3JhZGVyIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBtdXN0IGJlIHVwZ3JhZGVyCiAgICAvLyBzcmMvc3JjL2NvbnRyYWN0LnB5OjQ2OQogICAgLy8gYXJjNC5lbWl0KFZlcnNpb25VcGRhdGVkKGNvbnRyYWN0X3ZlcnNpb24sIGRlcGxveW1lbnRfdmVyc2lvbikpCiAgICBmcmFtZV9kaWcgLTIKICAgIGZyYW1lX2RpZyAtMQogICAgY29uY2F0CiAgICBtZXRob2QgIlZlcnNpb25VcGRhdGVkKHVpbnQ2NCx1aW50NjQpIgogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIC8vIHNyYy9zcmMvY29udHJhY3QucHk6NDcwCiAgICAvLyBzZWxmLmNvbnRyYWN0X3ZlcnNpb24gPSBjb250cmFjdF92ZXJzaW9uLm5hdGl2ZQogICAgZnJhbWVfZGlnIC0yCiAgICBidG9pCiAgICAvLyBzcmMvc3JjL2NvbnRyYWN0LnB5OjQxMgogICAgLy8gc2VsZi5jb250cmFjdF92ZXJzaW9uID0gVUludDY0KCkKICAgIGJ5dGUgImNvbnRyYWN0X3ZlcnNpb24iCiAgICAvLyBzcmMvc3JjL2NvbnRyYWN0LnB5OjQ3MAogICAgLy8gc2VsZi5jb250cmFjdF92ZXJzaW9uID0gY29udHJhY3RfdmVyc2lvbi5uYXRpdmUKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzcmMvc3JjL2NvbnRyYWN0LnB5OjQ3MQogICAgLy8gc2VsZi5kZXBsb3ltZW50X3ZlcnNpb24gPSBkZXBsb3ltZW50X3ZlcnNpb24ubmF0aXZlCiAgICBmcmFtZV9kaWcgLTEKICAgIGJ0b2kKICAgIC8vIHNyYy9zcmMvY29udHJhY3QucHk6NDEzCiAgICAvLyBzZWxmLmRlcGxveW1lbnRfdmVyc2lvbiA9IFVJbnQ2NCgpCiAgICBieXRlICJkZXBsb3ltZW50X3ZlcnNpb24iCiAgICAvLyBzcmMvc3JjL2NvbnRyYWN0LnB5OjQ3MQogICAgLy8gc2VsZi5kZXBsb3ltZW50X3ZlcnNpb24gPSBkZXBsb3ltZW50X3ZlcnNpb24ubmF0aXZlCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgcmV0c3ViCgoKLy8gY29udHJhY3QuVXBncmFkZWFibGUuYXBwcm92ZV91cGRhdGUoYXBwcm92YWw6IGJ5dGVzKSAtPiB2b2lkOgphcHByb3ZlX3VwZGF0ZToKICAgIC8vIHNyYy9zcmMvY29udHJhY3QucHk6NDgyLTQ4MwogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICAvLyBkZWYgYXBwcm92ZV91cGRhdGUoc2VsZiwgYXBwcm92YWw6IGFyYzQuQm9vbCkgLT4gTm9uZToKICAgIHByb3RvIDEgMAogICAgLy8gc3JjL3NyYy9jb250cmFjdC5weTo0ODQKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyID09IHNlbGYub3duZXIsICJtdXN0IGJlIG93bmVyIgogICAgdHhuIFNlbmRlcgogICAgaW50IDAKICAgIC8vIHNyYy9zcmMvY29udHJhY3QucHk6NzcKICAgIC8vIHNlbGYub3duZXIgPSBBY2NvdW50KCkKICAgIGJ5dGUgIm93bmVyIgogICAgLy8gc3JjL3NyYy9jb250cmFjdC5weTo0ODQKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyID09IHNlbGYub3duZXIsICJtdXN0IGJlIG93bmVyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLm93bmVyIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBtdXN0IGJlIG93bmVyCiAgICAvLyBzcmMvc3JjL2NvbnRyYWN0LnB5OjQ4NQogICAgLy8gYXJjNC5lbWl0KFVwZGF0ZUFwcHJvdmVkKGFyYzQuQWRkcmVzcyhzZWxmLm93bmVyKSwgYXBwcm92YWwpKQogICAgaW50IDAKICAgIC8vIHNyYy9zcmMvY29udHJhY3QucHk6NzcKICAgIC8vIHNlbGYub3duZXIgPSBBY2NvdW50KCkKICAgIGJ5dGUgIm93bmVyIgogICAgLy8gc3JjL3NyYy9jb250cmFjdC5weTo0ODUKICAgIC8vIGFyYzQuZW1pdChVcGRhdGVBcHByb3ZlZChhcmM0LkFkZHJlc3Moc2VsZi5vd25lciksIGFwcHJvdmFsKSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5vd25lciBleGlzdHMKICAgIGZyYW1lX2RpZyAtMQogICAgY29uY2F0CiAgICBtZXRob2QgIlVwZGF0ZUFwcHJvdmVkKGFkZHJlc3MsYm9vbCkiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgLy8gc3JjL3NyYy9jb250cmFjdC5weTo0ODYKICAgIC8vIHNlbGYudXBkYXRhYmxlID0gYXBwcm92YWwubmF0aXZlCiAgICBmcmFtZV9kaWcgLTEKICAgIGludCAwCiAgICBnZXRiaXQKICAgIC8vIHNyYy9zcmMvY29udHJhY3QucHk6NDE0CiAgICAvLyBzZWxmLnVwZGF0YWJsZSA9IGJvb2woMSkKICAgIGJ5dGUgInVwZGF0YWJsZSIKICAgIC8vIHNyYy9zcmMvY29udHJhY3QucHk6NDg2CiAgICAvLyBzZWxmLnVwZGF0YWJsZSA9IGFwcHJvdmFsLm5hdGl2ZQogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIHJldHN1YgoKCi8vIGNvbnRyYWN0LlVwZ3JhZGVhYmxlLmdyYW50X3VwZ3JhZGVyKHVwZ3JhZGVyOiBieXRlcykgLT4gdm9pZDoKZ3JhbnRfdXBncmFkZXI6CiAgICAvLyBzcmMvc3JjL2NvbnRyYWN0LnB5OjQ4OC00ODkKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgLy8gZGVmIGdyYW50X3VwZ3JhZGVyKHNlbGYsIHVwZ3JhZGVyOiBhcmM0LkFkZHJlc3MpIC0+IE5vbmU6CiAgICBwcm90byAxIDAKICAgIC8vIHNyYy9zcmMvY29udHJhY3QucHk6NDkwCiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzLCAibXVzdCBiZSBjcmVhdG9yIgogICAgdHhuIFNlbmRlcgogICAgZ2xvYmFsIENyZWF0b3JBZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIG11c3QgYmUgY3JlYXRvcgogICAgLy8gc3JjL3NyYy9jb250cmFjdC5weTo0OTEKICAgIC8vIGFyYzQuZW1pdChVcGdyYWRlckdyYW50ZWQoYXJjNC5BZGRyZXNzKHNlbGYudXBncmFkZXIpLCB1cGdyYWRlcikpCiAgICBpbnQgMAogICAgLy8gc3JjL3NyYy9jb250cmFjdC5weTo0MTUKICAgIC8vIHNlbGYudXBncmFkZXIgPSBBY2NvdW50KCkKICAgIGJ5dGUgInVwZ3JhZGVyIgogICAgLy8gc3JjL3NyYy9jb250cmFjdC5weTo0OTEKICAgIC8vIGFyYzQuZW1pdChVcGdyYWRlckdyYW50ZWQoYXJjNC5BZGRyZXNzKHNlbGYudXBncmFkZXIpLCB1cGdyYWRlcikpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudXBncmFkZXIgZXhpc3RzCiAgICBmcmFtZV9kaWcgLTEKICAgIGNvbmNhdAogICAgbWV0aG9kICJVcGdyYWRlckdyYW50ZWQoYWRkcmVzcyxhZGRyZXNzKSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICAvLyBzcmMvc3JjL2NvbnRyYWN0LnB5OjQxNQogICAgLy8gc2VsZi51cGdyYWRlciA9IEFjY291bnQoKQogICAgYnl0ZSAidXBncmFkZXIiCiAgICAvLyBzcmMvc3JjL2NvbnRyYWN0LnB5OjQ5MgogICAgLy8gc2VsZi51cGdyYWRlciA9IHVwZ3JhZGVyLm5hdGl2ZQogICAgZnJhbWVfZGlnIC0xCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgcmV0c3ViCgoKLy8gY29udHJhY3QuVXBncmFkZWFibGUub25fdXBkYXRlKCkgLT4gdm9pZDoKb25fdXBkYXRlOgogICAgLy8gc3JjL3NyYy9jb250cmFjdC5weTo0NzMtNDc0CiAgICAvLyBAYXJjNC5iYXJlbWV0aG9kKGFsbG93X2FjdGlvbnM9WyJVcGRhdGVBcHBsaWNhdGlvbiJdKQogICAgLy8gZGVmIG9uX3VwZGF0ZShzZWxmKSAtPiBOb25lOgogICAgcHJvdG8gMCAwCiAgICAvLyBzcmMvc3JjL2NvbnRyYWN0LnB5OjQ3NS00NzgKICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwogICAgLy8gIyBXQVJOSU5HOiBUaGlzIGFwcCBjYW4gYmUgdXBkYXRlZCBieSB0aGUgY3JlYXRvcgogICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBzZWxmLnVwZ3JhZGVyLCAibXVzdCBiZSB1cGdyYWRlciIKICAgIHR4biBTZW5kZXIKICAgIGludCAwCiAgICAvLyBzcmMvc3JjL2NvbnRyYWN0LnB5OjQxNQogICAgLy8gc2VsZi51cGdyYWRlciA9IEFjY291bnQoKQogICAgYnl0ZSAidXBncmFkZXIiCiAgICAvLyBzcmMvc3JjL2NvbnRyYWN0LnB5OjQ3NS00NzgKICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwogICAgLy8gIyBXQVJOSU5HOiBUaGlzIGFwcCBjYW4gYmUgdXBkYXRlZCBieSB0aGUgY3JlYXRvcgogICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBzZWxmLnVwZ3JhZGVyLCAibXVzdCBiZSB1cGdyYWRlciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi51cGdyYWRlciBleGlzdHMKICAgID09CiAgICBhc3NlcnQgLy8gbXVzdCBiZSB1cGdyYWRlcgogICAgLy8gc3JjL3NyYy9jb250cmFjdC5weTo0NzkKICAgIC8vIGFzc2VydCBzZWxmLnVwZGF0YWJsZSA9PSBVSW50NjQoMSksICJub3QgYXBwcm92ZWQiCiAgICBpbnQgMAogICAgLy8gc3JjL3NyYy9jb250cmFjdC5weTo0MTQKICAgIC8vIHNlbGYudXBkYXRhYmxlID0gYm9vbCgxKQogICAgYnl0ZSAidXBkYXRhYmxlIgogICAgLy8gc3JjL3NyYy9jb250cmFjdC5weTo0NzkKICAgIC8vIGFzc2VydCBzZWxmLnVwZGF0YWJsZSA9PSBVSW50NjQoMSksICJub3QgYXBwcm92ZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudXBkYXRhYmxlIGV4aXN0cwogICAgaW50IDEKICAgID09CiAgICBhc3NlcnQgLy8gbm90IGFwcHJvdmVkCiAgICByZXRzdWIKCgovLyBjb250cmFjdC5PU0FSQzIwMFRva2VuRmFjdG9yeS5fX2luaXRfXygpIC0+IHZvaWQ6Cl9faW5pdF9fOgogICAgLy8gc3JjL3NyYy9jb250cmFjdC5weToxMjA5CiAgICAvLyBkZWYgX19pbml0X18oc2VsZikgLT4gTm9uZToKICAgIHByb3RvIDAgMAogICAgLy8gc3JjL3NyYy9jb250cmFjdC5weToxMjEwCiAgICAvLyBzdXBlcigpLl9faW5pdF9fKCkKICAgIGNhbGxzdWIgQmFzZUZhY3RvcnkuX19pbml0X18KICAgIHJldHN1YgoKCi8vIGNvbnRyYWN0LkJhc2VGYWN0b3J5Ll9faW5pdF9fKCkgLT4gdm9pZDoKQmFzZUZhY3RvcnkuX19pbml0X186CiAgICAvLyBzcmMvc3JjL2NvbnRyYWN0LnB5OjExNzQKICAgIC8vIGRlZiBfX2luaXRfXyhzZWxmKSAtPiBOb25lOiAgIyBwcmFnbWE6IG5vIGNvdmVyCiAgICBwcm90byAwIDAKICAgIC8vIHNyYy9zcmMvY29udHJhY3QucHk6NDEyCiAgICAvLyBzZWxmLmNvbnRyYWN0X3ZlcnNpb24gPSBVSW50NjQoKQogICAgYnl0ZSAiY29udHJhY3RfdmVyc2lvbiIKICAgIC8vIHNyYy9zcmMvY29udHJhY3QucHk6MTE3OC0xMTc5CiAgICAvLyAjIHVwZ3JhZGVhYmxlIHN0YXRlCiAgICAvLyBzZWxmLmNvbnRyYWN0X3ZlcnNpb24gPSBVSW50NjQoKQogICAgaW50IDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzcmMvc3JjL2NvbnRyYWN0LnB5OjQxMwogICAgLy8gc2VsZi5kZXBsb3ltZW50X3ZlcnNpb24gPSBVSW50NjQoKQogICAgYnl0ZSAiZGVwbG95bWVudF92ZXJzaW9uIgogICAgLy8gc3JjL3NyYy9jb250cmFjdC5weToxMTgwCiAgICAvLyBzZWxmLmRlcGxveW1lbnRfdmVyc2lvbiA9IFVJbnQ2NCgpCiAgICBpbnQgMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNyYy9zcmMvY29udHJhY3QucHk6NDE0CiAgICAvLyBzZWxmLnVwZGF0YWJsZSA9IGJvb2woMSkKICAgIGJ5dGUgInVwZGF0YWJsZSIKICAgIC8vIHNyYy9zcmMvY29udHJhY3QucHk6MTE4MQogICAgLy8gc2VsZi51cGRhdGFibGUgPSBib29sKDEpCiAgICBpbnQgMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNyYy9zcmMvY29udHJhY3QucHk6NDE1CiAgICAvLyBzZWxmLnVwZ3JhZGVyID0gQWNjb3VudCgpCiAgICBieXRlICJ1cGdyYWRlciIKICAgIC8vIHNyYy9zcmMvY29udHJhY3QucHk6MTE4MgogICAgLy8gc2VsZi51cGdyYWRlciA9IEdsb2JhbC5jcmVhdG9yX2FkZHJlc3MKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgYXBwX2dsb2JhbF9wdXQKICAgIHJldHN1Ygo=",
        "clear": "I3ByYWdtYSB2ZXJzaW9uIDEwCgpjb250cmFjdC5PU0FSQzIwMFRva2VuRmFjdG9yeS5jbGVhcl9zdGF0ZV9wcm9ncmFtOgogICAgLy8gc3JjL3NyYy9jb250cmFjdC5weToxMjA4CiAgICAvLyBjbGFzcyBPU0FSQzIwMFRva2VuRmFjdG9yeShCYXNlRmFjdG9yeSk6CiAgICBpbnQgMQogICAgcmV0dXJuCg=="
    },
    "state": {
        "global": {
            "num_byte_slices": 2,
            "num_uints": 3
        },
        "local": {
            "num_byte_slices": 0,
            "num_uints": 0
        }
    },
    "schema": {
        "global": {
            "declared": {
                "contract_version": {
                    "type": "uint64",
                    "key": "contract_version"
                },
                "deployment_version": {
                    "type": "uint64",
                    "key": "deployment_version"
                },
                "owner": {
                    "type": "bytes",
                    "key": "owner"
                },
                "updatable": {
                    "type": "uint64",
                    "key": "updatable"
                },
                "upgrader": {
                    "type": "bytes",
                    "key": "upgrader"
                }
            },
            "reserved": {}
        },
        "local": {
            "declared": {},
            "reserved": {}
        }
    },
    "contract": {
        "name": "OSARC200TokenFactory",
        "methods": [
            {
                "name": "create",
                "args": [],
                "readonly": false,
                "returns": {
                    "type": "uint64"
                },
                "desc": "Create airdrop.\nArguments: - owner, who is the beneficiary - funder, who funded the contract - deadline, funding deadline - initial, initial funded value not including lockup bonus\nReturns: - app id"
            },
            {
                "name": "set_version",
                "args": [
                    {
                        "type": "uint64",
                        "name": "contract_version"
                    },
                    {
                        "type": "uint64",
                        "name": "deployment_version"
                    }
                ],
                "readonly": false,
                "returns": {
                    "type": "void"
                }
            },
            {
                "name": "approve_update",
                "args": [
                    {
                        "type": "bool",
                        "name": "approval"
                    }
                ],
                "readonly": false,
                "returns": {
                    "type": "void"
                }
            },
            {
                "name": "grant_upgrader",
                "args": [
                    {
                        "type": "address",
                        "name": "upgrader"
                    }
                ],
                "readonly": false,
                "returns": {
                    "type": "void"
                }
            },
            {
                "name": "transfer",
                "args": [
                    {
                        "type": "address",
                        "name": "new_owner"
                    }
                ],
                "readonly": false,
                "returns": {
                    "type": "void"
                },
                "desc": "Transfer ownership of the contract to a new owner. Emits OwnershipTransferred event."
            }
        ],
        "networks": {}
    },
    "bare_call_config": {
        "update_application": "CALL",
        "no_op": "CREATE"
    }
};
/**
 * Exposes methods for constructing all available smart contract calls
 */
export class Osarc200TokenFactoryCallFactory {
    /**
     * Gets available create call factories
     */
    static get create() {
        return {
            /**
             * Constructs a create call for the OSARC200TokenFactory smart contract using a bare call
             *
             * @param params Any parameters for the call
             * @returns A TypedCallParams object for the call
             */
            bare(params = {}) {
                return {
                    method: undefined,
                    methodArgs: undefined,
                    ...params,
                };
            },
        };
    }
    /**
     * Gets available update call factories
     */
    static get update() {
        return {
            /**
             * Constructs an update call for the OSARC200TokenFactory smart contract using a bare call
             *
             * @param params Any parameters for the call
             * @returns A TypedCallParams object for the call
             */
            bare(params = {}) {
                return {
                    method: undefined,
                    methodArgs: undefined,
                    ...params,
                };
            },
        };
    }
    /**
     * Constructs a no op call for the create()uint64 ABI method
     *
     * Create airdrop.
  Arguments: - owner, who is the beneficiary - funder, who funded the contract - deadline, funding deadline - initial, initial funded value not including lockup bonus
  Returns: - app id
     *
     * @param args Any args for the contract call
     * @param params Any additional parameters for the call
     * @returns A TypedCallParams object for the call
     */
    static create(args, params) {
        return {
            method: 'create()uint64',
            methodArgs: Array.isArray(args) ? args : [],
            ...params,
        };
    }
    /**
     * Constructs a no op call for the set_version(uint64,uint64)void ABI method
     *
     * @param args Any args for the contract call
     * @param params Any additional parameters for the call
     * @returns A TypedCallParams object for the call
     */
    static setVersion(args, params) {
        return {
            method: 'set_version(uint64,uint64)void',
            methodArgs: Array.isArray(args) ? args : [args.contractVersion, args.deploymentVersion],
            ...params,
        };
    }
    /**
     * Constructs a no op call for the approve_update(bool)void ABI method
     *
     * @param args Any args for the contract call
     * @param params Any additional parameters for the call
     * @returns A TypedCallParams object for the call
     */
    static approveUpdate(args, params) {
        return {
            method: 'approve_update(bool)void',
            methodArgs: Array.isArray(args) ? args : [args.approval],
            ...params,
        };
    }
    /**
     * Constructs a no op call for the grant_upgrader(address)void ABI method
     *
     * @param args Any args for the contract call
     * @param params Any additional parameters for the call
     * @returns A TypedCallParams object for the call
     */
    static grantUpgrader(args, params) {
        return {
            method: 'grant_upgrader(address)void',
            methodArgs: Array.isArray(args) ? args : [args.upgrader],
            ...params,
        };
    }
    /**
     * Constructs a no op call for the transfer(address)void ABI method
     *
     * Transfer ownership of the contract to a new owner. Emits OwnershipTransferred event.
     *
     * @param args Any args for the contract call
     * @param params Any additional parameters for the call
     * @returns A TypedCallParams object for the call
     */
    static transfer(args, params) {
        return {
            method: 'transfer(address)void',
            methodArgs: Array.isArray(args) ? args : [args.newOwner],
            ...params,
        };
    }
}
/**
 * A client to make calls to the OSARC200TokenFactory smart contract
 */
export class Osarc200TokenFactoryClient {
    algod;
    /**
     * The underlying `ApplicationClient` for when you want to have more flexibility
     */
    appClient;
    sender;
    /**
     * Creates a new instance of `Osarc200TokenFactoryClient`
     *
     * @param appDetails appDetails The details to identify the app to deploy
     * @param algod An algod client instance
     */
    constructor(appDetails, algod) {
        this.algod = algod;
        this.sender = appDetails.sender;
        this.appClient = algokit.getAppClient({
            ...appDetails,
            app: APP_SPEC
        }, algod);
    }
    /**
     * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type
     *
     * @param result The AppCallTransactionResult to be mapped
     * @param returnValueFormatter An optional delegate to format the return value if required
     * @returns The smart contract response with an updated return value
     */
    mapReturnValue(result, returnValueFormatter) {
        if (result.return?.decodeError) {
            throw result.return.decodeError;
        }
        const returnValue = result.return?.returnValue !== undefined && returnValueFormatter !== undefined
            ? returnValueFormatter(result.return.returnValue)
            : result.return?.returnValue;
        return { ...result, return: returnValue };
    }
    /**
     * Calls the ABI method with the matching signature using an onCompletion code of NO_OP
     *
     * @param typedCallParams An object containing the method signature, args, and any other relevant parameters
     * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type
     * @returns The result of the smart contract call
     */
    async call(typedCallParams, returnValueFormatter) {
        return this.mapReturnValue(await this.appClient.call(typedCallParams), returnValueFormatter);
    }
    /**
     * Idempotently deploys the OSARC200TokenFactory smart contract.
     *
     * @param params The arguments for the contract calls and any additional parameters for the call
     * @returns The deployment result
     */
    deploy(params = {}) {
        const createArgs = params.createCall?.(Osarc200TokenFactoryCallFactory.create);
        const updateArgs = params.updateCall?.(Osarc200TokenFactoryCallFactory.update);
        return this.appClient.deploy({
            ...params,
            updateArgs,
            createArgs,
            createOnCompleteAction: createArgs?.onCompleteAction,
        });
    }
    /**
     * Gets available create methods
     */
    get create() {
        const $this = this;
        return {
            /**
             * Creates a new instance of the OSARC200TokenFactory smart contract using a bare call.
             *
             * @param args The arguments for the bare call
             * @returns The create result
             */
            async bare(args = {}) {
                return $this.mapReturnValue(await $this.appClient.create(args));
            },
        };
    }
    /**
     * Gets available update methods
     */
    get update() {
        const $this = this;
        return {
            /**
             * Updates an existing instance of the OSARC200TokenFactory smart contract using a bare call.
             *
             * @param args The arguments for the bare call
             * @returns The update result
             */
            async bare(args = {}) {
                return $this.mapReturnValue(await $this.appClient.update(args));
            },
        };
    }
    /**
     * Makes a clear_state call to an existing instance of the OSARC200TokenFactory smart contract.
     *
     * @param args The arguments for the bare call
     * @returns The clear_state result
     */
    clearState(args = {}) {
        return this.appClient.clearState(args);
    }
    /**
     * Calls the create()uint64 ABI method.
     *
     * Create airdrop.
  Arguments: - owner, who is the beneficiary - funder, who funded the contract - deadline, funding deadline - initial, initial funded value not including lockup bonus
  Returns: - app id
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The result of the call
     */
    create(args, params = {}) {
        return this.call(Osarc200TokenFactoryCallFactory.create(args, params));
    }
    /**
     * Calls the set_version(uint64,uint64)void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The result of the call
     */
    setVersion(args, params = {}) {
        return this.call(Osarc200TokenFactoryCallFactory.setVersion(args, params));
    }
    /**
     * Calls the approve_update(bool)void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The result of the call
     */
    approveUpdate(args, params = {}) {
        return this.call(Osarc200TokenFactoryCallFactory.approveUpdate(args, params));
    }
    /**
     * Calls the grant_upgrader(address)void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The result of the call
     */
    grantUpgrader(args, params = {}) {
        return this.call(Osarc200TokenFactoryCallFactory.grantUpgrader(args, params));
    }
    /**
     * Calls the transfer(address)void ABI method.
     *
     * Transfer ownership of the contract to a new owner. Emits OwnershipTransferred event.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The result of the call
     */
    transfer(args, params = {}) {
        return this.call(Osarc200TokenFactoryCallFactory.transfer(args, params));
    }
    /**
     * Extracts a binary state value out of an AppState dictionary
     *
     * @param state The state dictionary containing the state value
     * @param key The key of the state value
     * @returns A BinaryState instance containing the state value, or undefined if the key was not found
     */
    static getBinaryState(state, key) {
        const value = state[key];
        if (!value)
            return undefined;
        if (!('valueRaw' in value))
            throw new Error(`Failed to parse state value for ${key}; received an int when expected a byte array`);
        return {
            asString() {
                return value.value;
            },
            asByteArray() {
                return value.valueRaw;
            }
        };
    }
    /**
     * Extracts a integer state value out of an AppState dictionary
     *
     * @param state The state dictionary containing the state value
     * @param key The key of the state value
     * @returns An IntegerState instance containing the state value, or undefined if the key was not found
     */
    static getIntegerState(state, key) {
        const value = state[key];
        if (!value)
            return undefined;
        if ('valueRaw' in value)
            throw new Error(`Failed to parse state value for ${key}; received a byte array when expected a number`);
        return {
            asBigInt() {
                return typeof value.value === 'bigint' ? value.value : BigInt(value.value);
            },
            asNumber() {
                return typeof value.value === 'bigint' ? Number(value.value) : value.value;
            },
        };
    }
    /**
     * Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value
     */
    async getGlobalState() {
        const state = await this.appClient.getGlobalState();
        return {
            get contractVersion() {
                return Osarc200TokenFactoryClient.getIntegerState(state, 'contract_version');
            },
            get deploymentVersion() {
                return Osarc200TokenFactoryClient.getIntegerState(state, 'deployment_version');
            },
            get owner() {
                return Osarc200TokenFactoryClient.getBinaryState(state, 'owner');
            },
            get updatable() {
                return Osarc200TokenFactoryClient.getIntegerState(state, 'updatable');
            },
            get upgrader() {
                return Osarc200TokenFactoryClient.getBinaryState(state, 'upgrader');
            },
        };
    }
    compose() {
        const client = this;
        const atc = new AtomicTransactionComposer();
        let promiseChain = Promise.resolve();
        const resultMappers = [];
        return {
            create(args, params) {
                promiseChain = promiseChain.then(() => client.create(args, { ...params, sendParams: { ...params?.sendParams, skipSending: true, atc } }));
                resultMappers.push(undefined);
                return this;
            },
            setVersion(args, params) {
                promiseChain = promiseChain.then(() => client.setVersion(args, { ...params, sendParams: { ...params?.sendParams, skipSending: true, atc } }));
                resultMappers.push(undefined);
                return this;
            },
            approveUpdate(args, params) {
                promiseChain = promiseChain.then(() => client.approveUpdate(args, { ...params, sendParams: { ...params?.sendParams, skipSending: true, atc } }));
                resultMappers.push(undefined);
                return this;
            },
            grantUpgrader(args, params) {
                promiseChain = promiseChain.then(() => client.grantUpgrader(args, { ...params, sendParams: { ...params?.sendParams, skipSending: true, atc } }));
                resultMappers.push(undefined);
                return this;
            },
            transfer(args, params) {
                promiseChain = promiseChain.then(() => client.transfer(args, { ...params, sendParams: { ...params?.sendParams, skipSending: true, atc } }));
                resultMappers.push(undefined);
                return this;
            },
            get update() {
                const $this = this;
                return {
                    bare(args) {
                        promiseChain = promiseChain.then(() => client.update.bare({ ...args, sendParams: { ...args?.sendParams, skipSending: true, atc } }));
                        resultMappers.push(undefined);
                        return $this;
                    },
                };
            },
            clearState(args) {
                promiseChain = promiseChain.then(() => client.clearState({ ...args, sendParams: { ...args?.sendParams, skipSending: true, atc } }));
                resultMappers.push(undefined);
                return this;
            },
            addTransaction(txn, defaultSender) {
                promiseChain = promiseChain.then(async () => atc.addTransaction(await algokit.getTransactionWithSigner(txn, defaultSender ?? client.sender)));
                return this;
            },
            async atc() {
                await promiseChain;
                return atc;
            },
            async simulate(options) {
                await promiseChain;
                const result = await atc.simulate(client.algod, new modelsv2.SimulateRequest({ txnGroups: [], ...options }));
                return {
                    ...result,
                    returns: result.methodResults?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i](val.returnValue) : val.returnValue)
                };
            },
            async execute(sendParams) {
                await promiseChain;
                const result = await algokit.sendAtomicTransactionComposer({ atc, sendParams }, client.algod);
                return {
                    ...result,
                    returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i](val.returnValue) : val.returnValue)
                };
            }
        };
    }
}
